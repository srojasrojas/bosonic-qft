# QFT Phase Solver Toolkit

A Python toolkit for characterizing Quantum Fourier Transforms (QFT) based on equations 27 and 28 described in the manuscript `fourier_bosonica.pdf`. The repository includes numerical solvers, verification utilities, and matrix construction tools from computed phase parameters.

## Repository Structure

- **`qft_equation_27.py`**: Solver for λ_k parameters satisfying equation 27 (complex Hadamard matrix condition) using local/global optimization, with multi-run support and automatic verification.
- **`qft_equation_28.py`**: Solver for equation 28 (QFT-specific core condition). Can reuse equation 27 solutions as intelligent initial guesses, supports Monte Carlo sampling, and multiple global optimization methods.
- **`verify_equation.py`**: CLI utility to validate JSON files generated by solvers and check residuals against equations 27 or 28.
- **`qft_matrix_generator.py`**: Generates matrices U^(N), u^(N)_{m,n}, Φ^in, Φ^out and the final QFT matrix D^(N) from verified solutions; includes unitarity tests and comparison with standard QFT.
- **`fourier_bosonica.pdf`**: Theoretical reference for the project.

## Requirements

- Python 3.9 or higher (3.12 recommended)
- Dependencies listed in `requirements.txt`:
  - `numpy` (>=1.24.0)
  - `scipy` (>=1.11.0)
  - `matplotlib` (>=3.7.0, optional for visualization)

Install dependencies:
```bash
pip install -r requirements.txt
```

## Recommended Workflow

1. **Solve Equation 27**: Run `qft_equation_27.py` for a given dimension N and save verified solutions to JSON.
2. **Refine with Equation 28**: Use `qft_equation_28.py`, optionally loading the previous JSON via `--eq27-file` for better starting points.
3. **Verify Results**: Run `verify_equation.py` on generated JSON files; allows reviewing individual runs in multi-run mode.
4. **Build QFT Matrices**: Use `qft_matrix_generator.py` to transform λ_k parameters into physical matrices and validate unitarity/differences with standard QFT.

## Script Usage

### `qft_equation_27.py`

Solves the Complex Hadamard matrix condition (Equation 27) to find phase parameters λ_k.

**Basic Usage:**
```bash
python qft_equation_27.py N --method differential-evolution --output solutions/eq27_n7.json
```

**Multi-run with 10 different random seeds:**
```bash
python qft_equation_27.py 7 --method differential-evolution --multi-run 10 --output solutions/eq27_n7.json
```

**All available options:**
```bash
python qft_equation_27.py N \
  [--method {bfgs,lbfgs,nelder-mead,differential-evolution,all}] \
  [--tolerance 1e-10] \
  [--max-iter 2000] \
  [--seed 123] \
  [--multi-run 20] \
  [--output solutions/eq27_nN.json]
```

**Parameters:**
- `N`: QFT dimension
- `--method`: Optimization algorithm (use `all` to run multiple methods sequentially)
- `--multi-run`: Only available with `differential-evolution`; runs multiple times with different random seeds and saves only **mathematically verified** solutions
- `--tolerance`: Verification tolerance (default: 1e-10 for equation 27)
- `--output`: Export results with metadata to JSON; includes standard QFT phases as reference

**Key Features:**
- Enforces symmetry constraint λ_k = λ_{N-k} by default
- Computes analytical gradients for derivative-based methods
- **Quality filtering**: Only solutions satisfying `is_valid=True` are saved
- Multi-run mode finds multiple unique solutions and removes duplicates
- Each result stores residuals, iterations, and initialization type

### `qft_equation_28.py`

Solves the QFT-specific core condition (Equation 28) using equation 27 solutions as intelligent seeds.

**Basic Usage:**
```bash
python qft_equation_28.py 7 --eq27-file solutions/eq27_n7.json --method differential-evolution --output solutions/eq28_n7.json
```

**With custom tolerance:**
```bash
python qft_equation_28.py 7 --eq27-file solutions/eq27_n7.json --method differential-evolution --tolerance 2e-8 --output solutions/eq28_n7.json
```

**All available options:**
```bash
python qft_equation_28.py N \
  [--method {nelder-mead,differential-evolution,basin-hopping,multi-start}] \
  [--eq27-file solutions/eq27_nN.json] \
  [--random-starts 5] \
  [--monte-carlo 0.1] \
  [--no-symmetry] \
  [--tolerance 1e-8] \
  [--max-iter 1000] \
  [--output solutions/eq28_nN.json]
```

**Parameters:**
- `--eq27-file`: Loads multiple valid equation 27 solutions as seeds; script validates and reports how many are used
- `--method`: Optimization method
  - `differential-evolution` with `--eq27-file`: Tries **all** equation 27 solutions, selects best result
- `--tolerance`: Verification tolerance (default: 1e-8 for equation 28)
- `--monte-carlo`: Monte Carlo sampling ratio for large N (default: 0.1)
- `--no-symmetry`: Disables λ_k = λ_{N-k} constraint
- `--max-iter`: Maximum optimization iterations

**Computational Complexity:**

The script automatically determines whether to use Monte Carlo sampling based on problem size:

| N | Total Terms (N⁴) | Pairs (m,n) | Monte Carlo | Evaluations per Iteration |
|---|------------------|-------------|-------------|---------------------------|
| **≤10** | ≤10,000 | N² | **Disabled** | All terms computed exactly |
| **>10** | >10,000 | N² | **Enabled** | Samples `monte_carlo_ratio` fraction |

**Examples:**
- **N=7**: 2,401 terms × 49 pairs = 117,649 evaluations (exact computation)
- **N=20**: 160,000 terms × 400 pairs → samples 16,000 terms (with `--monte-carlo 0.1`)

**Key Features:**
- **Warm-start strategy**: Each equation 27 solution is refined with Nelder-Mead before seeding Differential Evolution
- **Seeded population**: DE population is initialized with the warm-started solution (not random)
- **Full verification**: Final solution is verified against **ALL** (m,n) pairs regardless of Monte Carlo setting
- **Quality filtering**: Only solutions satisfying `is_valid=True` are saved
- Multi-start mode combines random starts with equation 27 seeds and reports origin of best solution

### `verify_equation.py`

Independent verification tool to validate JSON solution files.

**Basic Usage:**
```bash
python verify_equation.py solutions/eq27_n7.json --equation 27
python verify_equation.py solutions/eq28_n7.json --equation 28
```

**Verify all runs in multi-run file:**
```bash
python verify_equation.py solutions/eq27_n7.json --equation 27 --verify-all-runs
```

**Brief output:**
```bash
python verify_equation.py solutions/eq27_n7.json --equation 27 --brief
```

**All available options:**
```bash
python verify_equation.py results.json \
  --equation {27,28} \
  [--tolerance 1e-12] \
  [--verify-all-runs] \
  [--brief]
```

**Parameters:**
- `--equation`: Which equation to verify (27 or 28)
- `--tolerance`: Custom verification tolerance
- `--verify-all-runs`: Re-verifies each stored run in multi-run files
- `--brief`: Condensed output format

**Output Information:**
- Loads JSON and prints residuals per equation
- Compares stored verification with recomputed values
- Reports standard QFT reference if included in file
- Shows statistics for multi-run results

### `qft_matrix_generator.py`

Constructs QFT matrices from λ_k solutions following the procedure in `fourier_bosonica.pdf`.

**Basic Usage:**
```bash
python qft_matrix_generator.py solutions/eq28_n7.json --output matrices_n7.json
```

**From equation 27 solution:**
```bash
python qft_matrix_generator.py solutions/eq27_n7.json --output matrices_n7.json --equation 27
```

**With custom tolerance:**
```bash
python qft_matrix_generator.py solutions/eq28_n4.json --output matrices_n4.json --tolerance 1e-12
```

**Generate PDF report with visualizations:**
```bash
python qft_matrix_generator.py solutions/eq28_n7.json --output matrices_n7.json --pdf report_n7.pdf
```

**All available options:**
```bash
python qft_matrix_generator.py input.json \
  --output matrices.json \
  [--equation {27,28}] \
  [--tolerance 1e-10] \
  [--pdf output.pdf] \
  [--verbose]
```

**Construction Procedure:**

1. **Calculate U^(N) matrix** using equation (25):
   ```
   U_{m,n}^{(N)} = (1/N) Σ_{k=0}^{N-1} exp(2πik(n-m)/N - iλ_k)
   ```

2. **Calculate u coefficients**:
   ```
   u_{m,n}^{(N)} = √N × U_{m,n}^{(N)}
   ```

3. **Build phase-shift matrices**:
   - Φ^in = diag(u_{0,0}*, u_{0,1}*, ..., u_{0,N-1}*)
   - Φ^out = diag(1, u_{1,0}*, u_{2,0}*, ..., u_{N-1,0}*)

4. **Calculate final QFT matrix**:
   ```
   D^(N) = Φ^out @ U^(N) @ Φ^in
   ```

**Output JSON Structure:**
```json
{
  "N": 7,
  "lambda_k": [...],
  "matrices": {
    "U_matrix": [...],
    "u_coefficients": [...],
    "Phi_in": [...],
    "Phi_out": [...],
    "D_qft_matrix": [...],
    "standard_qft": [...]
  },
  "verification": {
    "U_unitarity": {"is_unitary": true, "max_deviation": 1e-15},
    "D_unitarity": {"is_unitary": true, "max_deviation": 1e-15},
    "qft_correctness": {"is_correct_qft": true, "max_difference": 1e-14}
  },
  "metadata": {...}
}
```

**Features:**
- Auto-detects format (equation 27 or 28) and extracts λ_k
- For multi-run files: allows interactive selection of which solution to use
- Verifies unitarity: U†U = I and D†D = I
- Compares D^(N) with standard QFT matrix
- Complex matrices stored as nested lists [real, imag] pairs
- **PDF Report Generation**: Optional visual report with:
  - Rational π approximations for λ_k parameters (e.g., λ = 3π/4, √(5/7)π)
  - Color-coded magnitude and phase heatmaps for all matrices
  - Side-by-side comparison of generated vs standard QFT
  - Verification results and source metadata

## Output JSON Formats

JSON files generated by solvers follow these common structures:

### Equation 27 Format (Single Method):
```json
{
  "N": 7,
  "tolerance": 1e-10,
  "results": {
    "differential-evolution": {
      "method": "differential-evolution",
      "lambda_full": [...],
      "objective_value": 1.23e-15,
      "success": true,
      "iterations": 245,
      "solve_time": 123.45,
      "verification": {
        "is_valid": true,
        "max_residual": 8.9e-11,
        "mean_residual": 2.3e-11,
        "tolerance": 1e-10
      }
    }
  },
  "standard_qft": {
    "lambda_full": [0, 0, 0, ...],
    "verification": {...}
  }
}
```

### Equation 27 Multi-Run Format:
```json
{
  "N": 7,
  "tolerance": 1e-10,
  "results": {
    "differential-evolution": {
      "is_multi_run": true,
      "total_runs": 10,
      "verified_runs": 10,
      "unique_solutions": 10,
      "all_runs": [
        {
          "run_number": 1,
          "seed_used": 42,
          "lambda_full": [...],
          "objective_value": 1.23e-15,
          "verification": {"is_valid": true, ...}
        },
        ...
      ]
    }
  }
}
```

### Equation 28 Format:
```json
{
  "N": 7,
  "equation": 28,
  "method": "differential-evolution",
  "tolerance": 1e-8,
  "use_symmetry": true,
  "monte_carlo_ratio": 0.1,
  "eq27_file": "solutions/eq27_n7.json",
  "eq27_solutions_used": 10,
  "lambda_full": [...],
  "objective_value": 1.82e-15,
  "verification": {
    "is_valid": true,
    "max_residual": 9.2e-09,
    "pairs_checked": 49
  },
  "standard_qft_lambda": [...],
  "standard_qft_verification": {...}
}
```

## Practical Tips

### Tolerance Settings
- **Equation 27**: Use `--tolerance 1e-10` (default) for most cases
- **Equation 28**: Use `--tolerance 1e-8` (default); can relax to `2e-8` for difficult cases
- Tolerances too strict may reject numerically correct solutions
- Tolerances too loose may accept invalid solutions

### Multi-Run Strategy
- Use `--multi-run 10` (or more) with equation 27 to explore multiple minima
- Increases probability of finding diverse solutions useful for equation 28
- Script automatically removes duplicate solutions (within tolerance)

### Equation 27 → 28 Pipeline
```bash
# Step 1: Generate multiple equation 27 solutions
python qft_equation_27.py 7 --method differential-evolution --multi-run 10 --output solutions/eq27_n7.json

# Step 2: Verify all solutions
python verify_equation.py solutions/eq27_n7.json --equation 27 --verify-all-runs

# Step 3: Use all solutions as seeds for equation 28
python qft_equation_28.py 7 --eq27-file solutions/eq27_n7.json --method differential-evolution --output solutions/eq28_n7.json

# Step 4: Verify equation 28 solution
python verify_equation.py solutions/eq28_n7.json --equation 28

# Step 5: Generate matrices
python qft_matrix_generator.py solutions/eq28_n7.json --output matrices_n7.json
```

### Performance Optimization
- **Small N (≤7)**: All methods work well; differential-evolution recommended
- **Medium N (8-10)**: Use differential-evolution or basin-hopping; exact computation still feasible
- **Large N (>10)**: Monte Carlo automatically enabled; increase `--monte-carlo` ratio if accuracy suffers
- Increase `--max-iter` if optimization doesn't converge (default: 500 for eq27, 1000 for eq28)

### Verification Best Practices
- Always verify solutions before using them downstream
- Use `verify_equation.py` to detect numerical degradation in stored solutions
- Compare `max_residual` with `tolerance` to assess solution quality
- For equation 28: check that warm-start objective is improving

### Troubleshooting

**Problem: Equation 28 doesn't save solution**
- Check verification output: `Solution valid: False` means residuals exceed tolerance
- Try relaxing tolerance: `--tolerance 2e-8`
- Try more iterations: `--max-iter 2000`
- Verify equation 27 solutions are high quality

**Problem: Monte Carlo gives inconsistent results**
- Increase sampling ratio: `--monte-carlo 0.5`
- Or disable for smaller N by checking total terms < 10,000
- Verification always uses full computation regardless

**Problem: Matrix generator fails**
- Ensure input solution is verified valid
- Check λ_k values are finite and reasonable (not NaN or Inf)
- Try different tolerance for matrix verification

## Examples

### Example 1: Complete N=4 Pipeline
```bash
# Solve equation 27
python qft_equation_27.py 4 --method differential-evolution --output solutions/eq27_n4.json

# Verify
python verify_equation.py solutions/eq27_n4.json --equation 27

# Solve equation 28
python qft_equation_28.py 4 --eq27-file solutions/eq27_n4.json --method differential-evolution --output solutions/eq28_n4.json

# Generate matrices with PDF report
python qft_matrix_generator.py solutions/eq28_n4.json --output matrices_n4.json --pdf report_n4.pdf
```

### Example 2: Multi-Run N=7
```bash
# Generate 10 diverse solutions
python qft_equation_27.py 7 --method differential-evolution --multi-run 10 --output solutions/eq27_n7.json

# Verify all 10 runs
python verify_equation.py solutions/eq27_n7.json --equation 27 --verify-all-runs --brief

# Use all as seeds
python qft_equation_28.py 7 --eq27-file solutions/eq27_n7.json --method differential-evolution --output solutions/eq28_n7.json --tolerance 2e-8
```

### Example 3: Custom Tolerance
```bash
# Stricter tolerance for equation 27
python qft_equation_27.py 5 --method differential-evolution --tolerance 1e-12 --output solutions/eq27_n5_strict.json

# Relaxed tolerance for difficult equation 28
python qft_equation_28.py 5 --eq27-file solutions/eq27_n5_strict.json --tolerance 5e-8 --output solutions/eq28_n5.json
```

## References

- **`fourier_bosonica.pdf`**: Foundational document introducing equations 27 and 28, intermediate matrix definitions, and physical interpretation of λ_k parameters. Review this text for complete mathematical context.

## Citation

If you use this toolkit in your research, please cite the associated manuscript `fourier_bosonica.pdf`.

## License

[Specify your license here]

## Contact

[Your contact information]
